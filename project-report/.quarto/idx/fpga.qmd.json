{"title":"FPGA Design Overview","markdown":{"yaml":{"title":"FPGA Design Overview","format":"html"},"headingText":"Block Diagram","containsRefs":false,"markdown":"\n\nThe FPGA had a couple of tasks that were laid out by our project proposal. \nOne of the tasks was to control the light display. While the original plan was \nto get the light code sequence from SPRAM, we did not get to this point due to \nunforeseen circumstances. We were able to program it with a given RGB color string and used \nan FSM to shift the lights in different patterns. The FPGA also controlled the servo \nmotor that moved the “needle” of our jukebox. This was also controlled by an FSM. The \nservo motor design fully met our specs.\n\n\nThe block diagram for our FPGA design is given below. \n\n![Block diagram for FPGA design](images/e155_block_diagram.png)\n\n## LED Strip Control\n\nThe FPGA displayed a custom color sequence on a WS2812 RGB individually addressable LED strip with\n144 pixels/m. The data transfer protocol for the LEDs is NZR, non-return-to-zero communication.\nThis involved sending a PWM signal and changing the duty cycle of the pulses based on the data to be \nsent, like in the diagram below. \n\n![WS2812 communication protocol](images/ws2812.png)\n\nThis was accomplished using two FSMs: led_driver and led_shifter. led_driver shifted in a \nspecific number of bits to the LED strip by updating the duty cycle of the PWM signal for each \nbit. To save on space, a pattern of 6 colors was repeated across the entire LED strip, so this took\n144 bits (corresponding to 6 LEDs * 24 bits each). Each LED requires 24 bits (8 green, 8 red, 8 blue).\n\nled_shifter iterates through inputs to be sent to the led_driver. The same 144 bit string is sent\nto the LED strip 6 times over, then a reset signal is asserted (which just requires pulling the \noutput pin low for at least 50 microseconds). The original string is shifted by 24 bits so it \nlooks like the colors are \"sliding\" across the LEDs. This was successfully implemented, but no\nvideo was taken before all of the hardware broke.\n\n![led_driver FSM](images/led_driver_fsm.jpeg)\n![led_shifter FSM](images/led_shifter_fsm.jpeg)\n\n## Servo Control\nThe servo was implemented to control a \"needle\" that would lay on top of the \"record\" to look like\na real jukebox. An SG90 servo motor was used, which takes a PWM input with a duty cycle corresponding\nto the angle the servo should turn to. The PWM signal has a period of 20ms. An angle of -90 degrees\nrequires a pulse width of 1 ms, an angle of 0 degrees requires a pulse width of 1.5 ms, and an angle\n90 degrees requires a pulse width of 2.0 ms. \n\n![SG90 communication](images/sg90_info.png)\n\nThis was achieved using two FSMs and counters. servo_control outputs the PWM signal based on an \ninput angle, and just makes use of counters. song_timing asserts angles corresponding to a down,\nthen up, then back down position when a song is loaded to simulate changing a record. \n\n![servo_driver FSM](images/servo_driver_fsm.jpeg)\n\n![song_timing FSM](images/song_timing_fsm.jpeg)\n\n## SPRAM \n\nThe new feature we tried to implement on the FPGA was of SPRAM. \nIn our original design we wanted the FLASH of the MCU to transmit data to the SPRAM \nof the FPGA via SPI to store color data for the lights. \nWhile we had code that would upload the SPI transmitted bits to\nthe SPRAM and it was able to synthesize we never got a chance to test it before our \nproject ended up getting shorted.\n","srcMarkdownNoYaml":"\n\nThe FPGA had a couple of tasks that were laid out by our project proposal. \nOne of the tasks was to control the light display. While the original plan was \nto get the light code sequence from SPRAM, we did not get to this point due to \nunforeseen circumstances. We were able to program it with a given RGB color string and used \nan FSM to shift the lights in different patterns. The FPGA also controlled the servo \nmotor that moved the “needle” of our jukebox. This was also controlled by an FSM. The \nservo motor design fully met our specs.\n\n## Block Diagram\n\nThe block diagram for our FPGA design is given below. \n\n![Block diagram for FPGA design](images/e155_block_diagram.png)\n\n## LED Strip Control\n\nThe FPGA displayed a custom color sequence on a WS2812 RGB individually addressable LED strip with\n144 pixels/m. The data transfer protocol for the LEDs is NZR, non-return-to-zero communication.\nThis involved sending a PWM signal and changing the duty cycle of the pulses based on the data to be \nsent, like in the diagram below. \n\n![WS2812 communication protocol](images/ws2812.png)\n\nThis was accomplished using two FSMs: led_driver and led_shifter. led_driver shifted in a \nspecific number of bits to the LED strip by updating the duty cycle of the PWM signal for each \nbit. To save on space, a pattern of 6 colors was repeated across the entire LED strip, so this took\n144 bits (corresponding to 6 LEDs * 24 bits each). Each LED requires 24 bits (8 green, 8 red, 8 blue).\n\nled_shifter iterates through inputs to be sent to the led_driver. The same 144 bit string is sent\nto the LED strip 6 times over, then a reset signal is asserted (which just requires pulling the \noutput pin low for at least 50 microseconds). The original string is shifted by 24 bits so it \nlooks like the colors are \"sliding\" across the LEDs. This was successfully implemented, but no\nvideo was taken before all of the hardware broke.\n\n![led_driver FSM](images/led_driver_fsm.jpeg)\n![led_shifter FSM](images/led_shifter_fsm.jpeg)\n\n## Servo Control\nThe servo was implemented to control a \"needle\" that would lay on top of the \"record\" to look like\na real jukebox. An SG90 servo motor was used, which takes a PWM input with a duty cycle corresponding\nto the angle the servo should turn to. The PWM signal has a period of 20ms. An angle of -90 degrees\nrequires a pulse width of 1 ms, an angle of 0 degrees requires a pulse width of 1.5 ms, and an angle\n90 degrees requires a pulse width of 2.0 ms. \n\n![SG90 communication](images/sg90_info.png)\n\nThis was achieved using two FSMs and counters. servo_control outputs the PWM signal based on an \ninput angle, and just makes use of counters. song_timing asserts angles corresponding to a down,\nthen up, then back down position when a song is loaded to simulate changing a record. \n\n![servo_driver FSM](images/servo_driver_fsm.jpeg)\n\n![song_timing FSM](images/song_timing_fsm.jpeg)\n\n## SPRAM \n\nThe new feature we tried to implement on the FPGA was of SPRAM. \nIn our original design we wanted the FLASH of the MCU to transmit data to the SPRAM \nof the FPGA via SPI to store color data for the lights. \nWhile we had code that would upload the SPI transmitted bits to\nthe SPRAM and it was able to synthesize we never got a chance to test it before our \nproject ended up getting shorted.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"fpga.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","theme":["united","brand"],"title":"FPGA Design Overview"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}